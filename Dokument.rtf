{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fmodern JetBrains Mono;}{\f1\fnil\fcharset0 Calibri;}}
{\colortbl ;\red167\green29\blue93;\red51\green51\blue51;\red99\green163\blue92;\red150\green152\blue150;\red0\green128\blue128;\red0\green134\blue179;\red255\green255\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\box\brdrdash\brdrw0 \cbpat7\sa200\sl276\slmult1\cf1\f0\fs20\lang7 import \cf2 matplotlib\cf3 .\cf2 pyplot \cf1 as \cf2 plt\line\cf1 import \cf2 numpy \cf1 as \cf2 np\line\cf1 from \cf2 scipy \cf1 import \cf2 signal\line\cf1 from \cf2 scipy\cf3 .\cf2 io \cf1 import \cf2 loadmat\line\line\line\cf1 def \cf2 nlms4echokomp\cf3 (\cf2 x\cf3 , \cf2 g\cf3 , \cf2 noise\cf3 , \cf2 alpha\cf3 , \cf2 mh\cf3 )\cf1 :\line     \cf4 """ The MATLAB function 'nlms4echokomp' simulates a system for acoustic echo compensation using NLMS algorithm\line     :param x:       Input speech signal from far speaker\line     :param g:       Impluse response of the simulated room\line     :param noise:   Speech signal from the near speaker and the background noise(s + n)\line     :param alpha:   Step size for the NLMS algorithm\line     :param mh:      Length of the compensation filter\line\line     :return s_diff:  relative system distance in dB\line     :return err:    error signal e(k)\line     :return x_hat:  output signal of the compensation filter\line     :return x_tilde:acoustic echo of far speakers\line     """\line\line     # Initialization of all the variables\line     \cf2 lx \cf1 = \cf2 len\cf3 (\cf2 x\cf3 )  \cf4 # Length of the input sequence\line     \cf2 mg \cf1 = \cf2 len\cf3 (\cf2 g\cf3 )  \cf4 # Length of the room impulse response(RIR)\line     \cf1 if \cf2 mh \cf1 > \cf2 mg\cf1 :\line         \cf2 mh \cf1 = \cf2 mg\line         \cf1 import \cf2 warnings\line         warnings\cf3 .\cf2 warn\cf3 (\cf5\b 'The compensation filter is shortened to fit the length of RIR!'\cf3\b0 , \cf2 UserWarning\cf3 )\line\line     \cf4 # Vectors are initialized to zero vectors.\line     \cf2 x_tilde \cf1 = \cf2 np\cf3 .\cf2 zeros\cf3 (\cf2 lx \cf1 - \cf2 mg\cf3 )\line     \cf2 x_hat \cf1 = \cf2 x_tilde\cf3 .\cf2 copy\cf3 ()\line     \cf2 err \cf1 = \cf2 x_tilde\cf3 .\cf2 copy\cf3 ()\line     \cf2 s_diff \cf1 = \cf2 x_tilde\cf3 .\cf2 copy\cf3 ()\line     \cf2 ERLE \cf1 = \cf2 np\cf3 .\cf2 ones\cf3 (\cf2 lx \cf1 - \cf2 mg \cf1 - \cf6 200\cf3 )\line     \cf2 h \cf1 = \cf2 np\cf3 .\cf2 zeros\cf3 (\cf2 mh\cf3 )\line\line     \cf4 # Realization of NLMS algorithm\line     \cf2 k \cf1 = \cf6 0\line     \cf1 for \cf2 index \cf1 in \cf2 range\cf3 (\cf2 mg\cf3 , \cf2 lx\cf3 )\cf1 :\line         \cf4 # Extract the last mg values(including the current value) from the\line         # input speech signal x, where x(i) represents the current value.\line         # todo your code\line         \cf2 x_block \cf1 = \cf2 x\cf3 [\cf2 k\cf1 :\cf2 index\cf3 ]\line\line         \cf4 # Filtering the input speech signal using room impulse response and adaptive filter. Please note that you don't\line         # need to implement the complete filtering here. A simple vector manipulation would be enough here\line         # todo your code:\line         \cf2 x_tilde\cf3 [\cf2 k\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 dot\cf3 (\cf2 g\cf3 .\cf2 T\cf3 , \cf2 x_block\cf3 )\line         \cf2 x_hat\cf3 [\cf2 k\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 dot\cf3 (\cf2 h\cf3 .\cf2 T\cf3 , \cf2 x_block\cf3 )\line\line         \cf4 # Calculating the estimated error signal\line         # todo your code\line         \cf2 err\cf3 [\cf2 k\cf3 ] \cf1 = \cf2 x_tilde\cf3 [\cf2 k\cf3 ] \cf1 - \cf2 x_hat\cf3 [\cf2 k\cf3 ]\line\line         \cf4 # Updating the filter\line         # todo your code\line         \cf1 if \cf2 np\cf3 .\cf2 dot\cf3 (\cf2 x_block\cf3 .\cf2 T\cf3 , \cf2 x_block\cf3 ) \cf1 != \cf6 0\cf1 :\line             \cf2 h \cf1 = \cf2 h \cf1 + \cf2 x_block \cf1 * \cf2 err\cf3 [\cf2 k\cf3 ] \cf1 * \cf2 alpha \cf1 / \cf2 np\cf3 .\cf2 dot\cf3 (\cf2 x_block\cf3 .\cf2 T\cf3 , \cf2 x_block\cf3 )\line         \cf4 # Calculating the relative system distance\line         # todo your code\line         \cf2 s_diff\cf3 [\cf2 k\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 dot\cf3 ((\cf2 g \cf1 - \cf2 h\cf3 ).\cf2 T\cf3 , \cf2 g \cf1 - \cf2 h\cf3 ) \cf1 / \cf2 np\cf3 .\cf2 dot\cf3 (\cf2 g\cf3 .\cf2 T\cf3 , \cf2 g\cf3 )\line\line         \cf1 if \cf2 k \cf1 > \cf6 199\cf1 :\line             if \cf2 np\cf3 .\cf2 mean\cf3 (\cf2 x_tilde\cf3 [\cf2 k \cf1 - \cf6 200\cf1 :\cf2 k\cf3 ] \cf1 ** \cf6 2\cf3 ) \cf1 !=\cf6 0 \cf1 and \cf2 np\cf3 .\cf2 mean\cf3 ((\cf2 x_tilde\cf3 [\cf2 k \cf1 - \cf6 200\cf1 :\cf2 k\cf3 ] \cf1 - \cf2 x_hat\cf3 [\cf2 k \cf1 - \cf6 200\cf1 :\cf2 k\cf3 ]) \cf1 ** \cf6 2\cf3 ) \cf1 != \cf6 0\cf1 :\line                 \cf2 ERLE\cf3 [\cf2 k \cf1 - \cf6 200\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 mean\cf3 (\cf2 x_tilde\cf3 [\cf2 k \cf1 - \cf6 200\cf1 :\cf2 k\cf3 ] \cf1 ** \cf6 2\cf3 ) \cf1 / \cf2 np\cf3 .\cf2 mean\cf3 ((\cf2 x_tilde\cf3 [\cf2 k \cf1 - \cf6 200\cf1 :\cf2 k\cf3 ] \cf1 - \cf2 x_hat\cf3 [\cf2 k \cf1 - \cf6 200\cf1 :\cf2 k\cf3 ]) \cf1 ** \cf6 2\cf3 )\line\line         \cf2 k \cf1 = \cf2 k \cf1 + \cf6 1  \cf4 # time index\line\line     # todo your code\line     \cf2 s_diff \cf1 = \cf6 10 \cf1 * \cf2 np\cf3 .\cf2 log10\cf3 (\cf2 s_diff\cf3 [\cf1 :\cf2 k\cf3 ]).\cf2 T\line     ERLE \cf1 = \cf6 10 \cf1 * \cf2 np\cf3 .\cf2 log10\cf3 (\cf2 ERLE\cf3 ).\cf2 T\line\line     \cf4 # Calculating the relative system distance in dB\line     \cf1 return \cf2 ERLE\cf3 , \cf2 s_diff\cf3 , \cf2 err\cf3 , \cf2 x_hat\cf3 , \cf2 x_tilde\line\line\line\cf4 # switch between exercises\line\cf2 exercise \cf1 = \cf6 5  \cf4 # choose between 1-7\line\line\cf2 f \cf1 = \cf2 np\cf3 .\cf2 load\cf3 (\cf5\b 'echocomp.npz'\cf3\b0 )\line\cf2 g \cf1 = \cf3 [\cf2 f\cf3 [\cf5\b 'g1'\cf3\b0 ], \cf2 f\cf3 [\cf5\b 'g2'\cf3\b0 ], \cf2 f\cf3 [\cf5\b 'g3'\cf3\b0 ]]\line\cf2 s \cf1 = \cf2 f\cf3 [\cf5\b 's'\cf3\b0 ]\line\line\cf4 # Generation of default values\line\cf2 alpha \cf1 = \cf6 0.1  \cf4 # Step size for NLMS\line\line\cf2 ls \cf1 = \cf2 len\cf3 (\cf2 s\cf3 )  \cf4 # Length of the speech signal\line\cf2 n0 \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.16\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )  \cf4 # White Noise\line\cf2 s \cf1 = \cf2 s \cf1 / \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf2 s\cf3 .\cf2 T\cf3 .\cf2 dot\cf3 (\cf2 s\cf3 )) \cf1 * \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf2 n0\cf3 .\cf2 T\cf3 .\cf2 dot\cf3 (\cf2 n0\cf3 ))  \cf4 # Number of curves in each plot (should not be changed)\line\cf2 vn \cf1 = \cf6 3  \cf4 # number of curves\line\cf2 noise \cf1 = \cf3 [\cf2 np\cf3 .\cf2 zeros\cf3 (\cf2 ls\cf3 , ) \cf1 for \cf2 i \cf1 in \cf2 range\cf3 (\cf2 vn\cf3 )]  \cf4 # no disturbance by noise\line\cf2 alphas \cf1 = \cf3 [\cf2 alpha \cf1 for \cf2 i \cf1 in \cf2 range\cf3 (\cf2 vn\cf3 )]  \cf4 # Step size factor for different exercises\line\cf2 mh \cf1 = \cf3 [\cf2 len\cf3 (\cf2 g\cf3 [\cf6 0\cf3 ]), \cf2 len\cf3 (\cf2 g\cf3 [\cf6 1\cf3 ]), \cf2 len\cf3 (\cf2 g\cf3 [\cf6 2\cf3 ])]  \cf4 # Length of the compensation filter\line\line\cf2 x \cf1 = \cf3 [\cf2 n0\cf3 .\cf2 copy\cf3 () \cf1 for \cf2 i \cf1 in \cf2 range\cf3 (\cf2 vn\cf3 )]  \cf4 # white noise as input signal\line\line # In the following part, the matrices and vectors must be adjusted to\line # meet the requirement for different exercises\line # (Exercise 1 can be simulated using only the initialized values above)\line\line\line\cf1 if \cf2 exercise \cf1 == \cf6 2\cf1 :\line     \cf4 # Only the value of input speech signal need to be changed. All the other\line     # vectors and parameters should not be modified\line\line     \cf2 x\cf3 [\cf6 0\cf3 ] \cf1 = \cf2 s  \cf4 # Speech signal\line     # todo your code\line     \cf2 x\cf3 [\cf6 1\cf3 ] \cf1 = \cf2 signal\cf3 .\cf2 windows\cf3 .\cf2 gaussian\cf3 (\cf2 ls\cf3 , \cf6 0.16\cf3 )  \cf4 # white noise\line\line     \cf2 b \cf1 = \cf3 [\cf6 1\cf3 ]\line     \cf2 a \cf1 = \cf3 [\cf6 1\cf3 , \cf1 -\cf6 0.5\cf3 ]\line     \cf2 x\cf3 [\cf6 2\cf3 ] \cf1 = \cf2 signal\cf3 .\cf2 lfilter\cf3 (\cf2 b\cf3 , \cf2 a\cf3 , \cf2 x\cf3 [\cf6 1\cf3 ])\line\line     \cf2 leg \cf1 = \cf3 (\cf5\b 'Speech'\cf3\b0 , \cf5\b 'white noise'\cf3\b0 , \cf5\b 'colorful noise'\cf3\b0 )\line     \cf2 title \cf1 = \cf5\b 'Different Input Signals'\line\cf1\b0 elif \cf2 exercise \cf1 == \cf6 3\cf1 :\line     \cf2 noise\cf3 [\cf6 0\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )  \cf4 # white noise\line     \cf2 noise\cf3 [\cf6 1\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.001\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )\line     \cf2 noise\cf3 [\cf6 2\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.01\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )\line     \cf2 leg \cf1 = \cf3 (\cf5\b 'n[0]'\cf3\b0 , \cf5\b 'n[1]'\cf3\b0 , \cf5\b 'n[2]'\cf3\b0 )\line     \cf2 title \cf1 = \cf5\b 'Different noises'\line     \cf1\b0 pass\line elif \cf2 exercise \cf1 == \cf6 4\cf1 :\line     \cf2 x\cf3 [\cf6 0\cf3 ] \cf1 = \cf2 s  \cf4 # Speech signal\line     \cf2 x\cf3 [\cf6 1\cf3 ] \cf1 = \cf2 s  \cf4 # Speech signal\line     \cf2 x\cf3 [\cf6 2\cf3 ] \cf1 = \cf2 s  \cf4 # Speech signal\line     \cf2 noise\cf3 [\cf6 0\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )  \cf4 # white noise\line     \cf2 noise\cf3 [\cf6 1\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.001\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )\line     \cf2 noise\cf3 [\cf6 2\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.01\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )\line     \cf2 leg \cf1 = \cf3 (\cf5\b 'n[0] = 0'\cf3\b0 , \cf5\b 'n[1] = 0.001'\cf3\b0 , \cf5\b 'n[2] = 0.01'\cf3\b0 )\line     \cf2 title \cf1 = \cf5\b 'Different noises n'\line     \cf1\b0 pass\line\line elif \cf2 exercise \cf1 == \cf6 5\cf1 :\line     \cf4 # todo your code\line     \cf2 noise\cf3 [\cf6 0\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.01\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 ) \cf4 # white noise\line     \cf2 noise\cf3 [\cf6 1\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.01\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )\line     \cf2 noise\cf3 [\cf6 2\cf3 ] \cf1 = \cf2 np\cf3 .\cf2 sqrt\cf3 (\cf6 0.01\cf3 ) \cf1 * \cf2 np\cf3 .\cf2 random\cf3 .\cf2 randn\cf3 (\cf2 ls\cf3 )\line     \cf2 alphas \cf1 = \cf3 [\cf6 0.1\cf3 , \cf6 0.5\cf3 , \cf6 1.0\cf3 ]\line     \cf2 leg \cf1 = \cf3 (\cf5\b 'alpha = 0.1'\cf3\b0 , \cf5\b 'alpha = 0.5'\cf3\b0 , \cf5\b 'alpha = 1.0'\cf3\b0 )\line     \cf2 title \cf1 = \cf5\b 'Different stepsizes alpha'\line     \cf1\b0 pass\line\line elif \cf2 exercise \cf1 == \cf6 6\cf1 :\line     \cf2 mh \cf1 = \cf3 [\cf2 len\cf3 (\cf2 g\cf3 [\cf6 0\cf3 ])\cf1 -\cf6 10\cf3 , \cf2 len\cf3 (\cf2 g\cf3 [\cf6 1\cf3 ])\cf1 -\cf6 30\cf3 , \cf2 len\cf3 (\cf2 g\cf3 [\cf6 2\cf3 ])\cf1 -\cf6 60\cf3 ]\line     \cf4 # todo your code\line     \cf1 pass\line\line elif \cf2 exercise \cf1 == \cf6 7\cf1 :\line     \cf4 # todo your code\line     \cf1 pass\line\cf4 # There should be appropriate legends and axis labels in each figure!\line\cf1 if \cf2 exercise \cf1 == \cf6 1\cf1 :\line     \cf2 ERLE\cf3 , \cf2 s_diff\cf3 , \cf2 e\cf3 , \cf2 x_h\cf3 , \cf2 x_t \cf1 = \cf2 nlms4echokomp\cf3 (\cf2 n0\cf3 , \cf2 g\cf3 [\cf6 0\cf3 ], \cf2 np\cf3 .\cf2 zeros\cf3 (\cf2 ls\cf3 ), \cf2 alpha\cf3 , \cf6 200\cf3 )\line     \cf2 t \cf1 = \cf2 np\cf3 .\cf2 arange\cf3 (\cf6 0.\cf3 , \cf2 len\cf3 (\cf2 x_h\cf3 ) \cf1 / \cf6 8000\cf3 , \cf6 1 \cf1 / \cf6 8000\cf3 )\line     \cf2 plt\cf3 .\cf2 figure\cf3 (\cf6 0\cf3 )\line     \cf2 plt\cf3 .\cf2 subplot\cf3 (\cf6 311\cf3 )\line     \cf2 t0 \cf1 = \cf2 np\cf3 .\cf2 arange\cf3 (\cf6 0.\cf3 , \cf2 len\cf3 (\cf2 n0\cf3 ) \cf1 / \cf6 8000\cf3 , \cf6 1 \cf1 / \cf6 8000\cf3 )\line     \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 t0\cf3 , \cf2 n0\cf3 )\line     \cf2 plt\cf3 .\cf2 xlabel\cf3 (\cf5\b 't [s]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 ylabel\cf3 (\cf5\b 'n0'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 subplot\cf3 (\cf6 312\cf3 )\line     \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 t\cf3 , \cf2 x_h\cf3 )\line     \cf2 plt\cf3 .\cf2 xlabel\cf3 (\cf5\b 't [s]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 ylabel\cf3 (\cf5\b 'x_h'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 subplot\cf3 (\cf6 313\cf3 )\line     \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 t\cf3 , \cf2 x_t\cf3 , \cf2 label\cf1 =\cf5\b 'x_t'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 t\cf3 , \cf2 e\cf3 , \cf2 label\cf1 =\cf5\b 'error'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 legend\cf3 (\cf2 loc\cf1 =\cf5\b 'best'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 xlabel\cf3 (\cf5\b 't [s]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 ylabel\cf3 (\cf5\b 'x_t/e'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 show\cf3 ()\line     \cf2 plt\cf3 .\cf2 figure\cf3 (\cf6 1\cf3 )\line     \cf2 plt\cf3 .\cf2 subplot\cf3 (\cf6 211\cf3 )\line     \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 t\cf3 , \cf2 s_diff\cf3 )\line     \cf2 plt\cf3 .\cf2 ylabel\cf3 (\cf5\b 's_diff [dB]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 subplot\cf3 (\cf6 212\cf3 )\line     \cf2 t2 \cf1 = \cf2 np\cf3 .\cf2 arange\cf3 (\cf6 0.\cf3 , \cf2 len\cf3 (\cf2 ERLE\cf3 ) \cf1 / \cf6 8000\cf3 , \cf6 1 \cf1 / \cf6 8000\cf3 )\line     \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 t2\cf3 , \cf2 ERLE\cf3 )\line     \cf2 plt\cf3 .\cf2 ylabel\cf3 (\cf5\b 'ERLE [dB]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 xlabel\cf3 (\cf5\b 't [s]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 show\cf3 ()\line\line\cf1 else:\line     for \cf2 i \cf1 in \cf2 range\cf3 (\cf2 vn\cf3 )\cf1 :\line         \cf4 # 3 system distances with different parameters are calculated here\line         # The input variables of 'nlms4echokomp' must be adapted according\line         # to different exercises.\line\line         \cf2 ERLE\cf3 , \cf2 s_diff\cf3 , \cf2 e\cf3 , \cf2 x_h\cf3 , \cf2 x_t \cf1 = \cf2 nlms4echokomp\cf3 (\cf2 x\cf3 [\cf2 i\cf3 ], \cf2 g\cf3 [\cf2 i\cf3 ], \cf2 noise\cf3 [\cf2 i\cf3 ], \cf2 alphas\cf3 [\cf2 i\cf3 ], \cf2 mh\cf3 [\cf2 i\cf3 ])\line         \cf2 plt\cf3 .\cf2 plot\cf3 (\cf2 s_diff\cf3 , \cf2 label\cf1 =\cf2 leg\cf3 [\cf2 i\cf3 ])\line\line     \cf2 plt\cf3 .\cf2 title\cf3 (\cf5\b 'Exercise ' \cf1\b0 + \cf2 str\cf3 (\cf2 exercise\cf3 ) \cf1 + \cf5\b ': ' \cf1\b0 + \cf2 title\cf3 )\line     \cf2 plt\cf3 .\cf2 xlabel\cf3 (\cf5\b 'k'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 ylabel\cf3 (\cf5\b 'D(k) [dB]'\cf3\b0 )\line     \cf2 plt\cf3 .\cf2 grid\cf3 (\cf1 True\cf3 )\line     \cf2 plt\cf3 .\cf2 legend\cf3 ()\line     \cf2 plt\cf3 .\cf2 show\cf3 ()\line\par

\pard\sa200\sl276\slmult1\cf0\f1\fs22\par
}
 